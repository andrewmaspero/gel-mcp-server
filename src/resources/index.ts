import { randomUUID } from "node:crypto";
import type {
	McpServer,
	RegisteredResource,
	RegisteredResourceTemplate,
} from "@modelcontextprotocol/sdk/server/mcp.js";
import { ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { ReadResourceResult } from "@modelcontextprotocol/sdk/types.js";
import { getDefaultConnection } from "../session.js";
import { onConnectionChanged } from "../events.js";

const CONNECTION_STATE_RESOURCE_URI = "resource://connection-state/current";
const DEFAULT_EPHEMERAL_TTL_MS = 1000 * 60 * 5; // 5 minutes

interface EphemeralResource {
	text: string;
	mimeType?: string;
	expiresAt: number;
	handle?: RegisteredResource;
}

const ephemeralResources = new Map<string, EphemeralResource>();
let serverRef: McpServer | null = null;
let ephemeralTemplateHandle: RegisteredResourceTemplate | null = null;

function readEphemeralResource(id?: string): ReadResourceResult {
	const uri = id ? `resource://ephemeral/${id}` : "resource://ephemeral/unknown";
	if (!id) {
		return {
			contents: [
				{
					uri,
					mimeType: "application/json",
					text: JSON.stringify(
						{
							error: "No resource id provided.",
						},
						null,
						2,
					),
				},
			],
		};
	}

	const entry = ephemeralResources.get(id);
	if (!entry) {
		return {
			contents: [
				{
					uri,
					mimeType: "application/json",
					text: JSON.stringify(
						{
							error: "Resource not found or has expired.",
							id,
						},
						null,
						2,
					),
				},
			],
		};
	}

	if (entry.expiresAt < Date.now()) {
		entry.handle?.remove?.();
		ephemeralResources.delete(id);
		return {
			contents: [
				{
					uri,
					mimeType: "application/json",
					text: JSON.stringify(
						{
							error: "Resource expired. Re-run the originating tool to regenerate the data.",
							id,
						},
						null,
						2,
					),
				},
			],
		};
	}

	return {
		contents: [
			{
				uri,
				mimeType: entry.mimeType ?? "text/plain",
				text: entry.text,
			},
		],
	};
}

function readConnectionState(): ReadResourceResult {
	const state = getDefaultConnection();
	const payload = {
		defaultInstance: state.defaultInstance ?? null,
		defaultBranch: state.defaultBranch ?? null,
		generatedAt: new Date().toISOString(),
	};

	return {
		contents: [
			{
				uri: CONNECTION_STATE_RESOURCE_URI,
				mimeType: "application/json",
				text: JSON.stringify(payload, null, 2),
			},
		],
	};
}

function registerConnectionStateResource(server: McpServer) {
	server.registerResource(
		"connection-state",
		CONNECTION_STATE_RESOURCE_URI,
		{
			name: "connection-state",
			title: "Connection State",
			description:
				"Snapshot of the current default instance and branch used for queries and schema operations.",
			mimeType: "application/json",
		},
		async () => readConnectionState(),
	);

	onConnectionChanged(async () => {
		try {
			await server.server.sendResourceUpdated({
				uri: CONNECTION_STATE_RESOURCE_URI,
			});
		} catch {
			// best effort
		}
	});
}

function registerEphemeralResource(
	id: string,
	entry: EphemeralResource,
	uri: string,
) {
	if (!serverRef) {
		return;
	}

	const resourceName = `ephemeral-${id}`;
	const handle = serverRef.registerResource(
		resourceName,
		uri,
		{
			name: resourceName,
			title: "Ephemeral Resource",
			description:
				"Short-lived resource backing large tool outputs that exceed inline response limits.",
			mimeType: entry.mimeType ?? "text/plain",
		},
		async () => readEphemeralResource(id),
	);
	entry.handle = handle;

	void serverRef.server.sendResourceUpdated({ uri }).catch(() => {
		// Ignore transport errors; clients can fetch on demand.
	});
}

export function registerAllResources(server: McpServer) {
	serverRef = server;
	registerConnectionStateResource(server);
	if (!ephemeralTemplateHandle) {
		const template = new ResourceTemplate("resource://ephemeral/{id}", {
			list: async () => ({
				resources: Array.from(ephemeralResources.entries())
					.filter(([, entry]) => entry.expiresAt >= Date.now())
					.map(([resourceId, entry]) => ({
						name: `ephemeral-${resourceId}`,
						uri: `resource://ephemeral/${resourceId}`,
						title: entry.mimeType ?? "Ephemeral Resource",
						description:
							"Short-lived resource generated by tools for large outputs.",
						mimeType: entry.mimeType ?? "text/plain",
					})),
			}),
			complete: {
				id: async () => Array.from(ephemeralResources.keys()),
			},
		});

		ephemeralTemplateHandle = server.resource(
			"ephemeral-resources",
			template,
			{
				name: "ephemeral-resources",
				title: "Ephemeral Resources",
				description:
					"Dynamic resources representing large tool outputs stored out-of-band.",
				mimeType: "text/plain",
			},
			async (_url, variables) =>
				readEphemeralResource(
					typeof variables?.id === "string" ? variables.id : undefined,
				),
		);
	}
}

export function createEphemeralTextResource(
	text: string,
	options: {
		mimeType?: string;
		ttlMs?: number;
	} = {},
): string {
	const id = randomUUID();
	const uri = `resource://ephemeral/${id}`;
	const entry: EphemeralResource = {
		text,
		mimeType: options.mimeType,
		expiresAt: Date.now() + (options.ttlMs ?? DEFAULT_EPHEMERAL_TTL_MS),
	};
	ephemeralResources.set(id, entry);

	if (serverRef) {
		registerEphemeralResource(id, entry, uri);
		void serverRef.server.sendResourceListChanged?.();
	}

	return uri;
}
